public interface ResourceWorkParameters extends WorkParameters {
    RegularFileProperty getSourceFile();
    RegularFileProperty getOutputFile();
    Property<String> getNamespace();
    Property<String> getFuncName();
    Property<String> getPrefix();
}

public abstract class GenerateResource implements WorkAction<ResourceWorkParameters> {
    @Override
    public void execute() {
        def inputFile = parameters.sourceFile.asFile.get()
        def outputFile = parameters.outputFile.asFile.get()
        def funcName = parameters.funcName.get()
        def namespace = parameters.namespace.get()
        def prefix = parameters.prefix.get()
            outputFile.withWriter { out ->
                    def inputBytes = inputFile.bytes
                    out.print '''#include <stddef.h>
#include <string_view>
extern "C" {
static const unsigned char contents[] = { '''

                    for (int i = 0; i < inputBytes.size(); i++) {
                        out.print String.format('0x%02x', (int) inputBytes[i] & 0xff)
                        out.print ', '
                    }
                    out.println """};
const unsigned char* ${prefix}${funcName}(size_t* len) {
  *len = ${inputBytes.size()};
  return contents;
}
}"""
                    if (!namespace.isEmpty()) {
                        out.println "namespace ${namespace} {"
                    }
                    out.println """std::string_view ${funcName}() {
  return {reinterpret_cast<const char*>(contents), ${inputBytes.size()}};
}"""
                    if (!namespace.isEmpty()) {
                        out.println '}'
                    }
                }
    }
}

public abstract class GenerateResources extends DefaultTask {
    private final ConfigurableFileCollection sourceFiles = project.objects.fileCollection();

    @SkipWhenEmpty
    @InputFiles
    @IgnoreEmptyDirectories
    @PathSensitive(PathSensitivity.RELATIVE)
    public ConfigurableFileCollection getSource() {
        return sourceFiles
    }

    public void source(Object... sources) {
        sourceFiles.from(sources);
    }

    @OutputDirectory
    public abstract DirectoryProperty getOutputDirectory();

    @Internal
    public abstract DirectoryProperty getBaseDirectory();

    @Internal
    public abstract Property<String> getPrefix();

    @Internal
    public abstract Property<String> getNamespace();

    @Inject
    public abstract WorkerExecutor getWorkerExecutor();

    @TaskAction
    public void createResources(InputChanges inputChanges) {
        WorkQueue workQueue = workerExecutor.noIsolation()
        def inputDir = baseDirectory.asFile.get()

        def libraries = [:]

        def filesToGenerate = []

        inputChanges.getFileChanges(getSource()).each { change ->
            if (change.fileType == FileType.DIRECTORY) return

            def fixedRelativePath = change.normalizedPath.replaceAll('[^a-zA-Z0-9]', '_')
            if (change.changeType == ChangeType.REMOVED) {
                def targetFile = outputDirectory.file("${fixedRelativePath}.cpp").get().asFile
                targetFile.delete()
            } else {
                filesToGenerate << fixedRelativePath
            }
        }

        for (File inputFile : source.asFileTree.files) {
            if (inputFile.isDirectory()) {
                continue
            }

            def relativePath = inputDir.toPath().relativize(inputFile.toPath()).toString()
            if (relativePath.startsWith('.')) {p
                continue
            }
            relativePath = relativePath.replaceAll('[^a-zA-Z0-9]', '_')
            // outputFile.parentFile.mkdirs()
            def funcName = "GetResource_" + relativePath
            if (relativePath.startsWith('libraries')) {
                libraries.put(inputFile.name, funcName);
            }
            if (filesToGenerate.contains(relativePath)) {
                Provider<RegularFile> generatedFile = outputDirectory.file("${relativePath}.cpp")
                workQueue.submit(GenerateResource.class) { parameters ->
                    parameters.sourceFile = inputFile
                    parameters.outputFile = generatedFile
                    parameters.prefix = this.prefix
                    parameters.funcName = funcName
                    parameters.namespace = this.namespace
                }
            }
        }
    //Make libraries
        def ns = namespace.get()
        def libraryOutputFile = outputDirectory.file("libstodeploy.cpp").get().asFile
        libraryOutputFile.withWriter { out ->
            out.println '''#include <string_view>
#include <utility>
#include <vector>'''
            if (!ns.isEmpty()) {
                out.println "namespace ${ns} {"
            }
            libraries.each { library ->
                out.println "std::string_view ${library.value}();"
            }
            out.println ''
            out.println '''std::vector<std::pair<const char*, std::string_view>> GetLibrariesToDeploy() {
std::vector<std::pair<const char*, std::string_view>> libraries;'''
            libraries.each { library ->
                out.println "libraries.emplace_back(std::make_pair(\"${library.key}\", ${library.value}()));"
            }
            out.println '''return libraries;
}'''
            if (!ns.isEmpty()) {
                out.println '}'
            }
        }
    }
}

ext.createGenerateResourcesTask = { name, _prefix, _namespace, project ->
    def task = project.tasks.create("generateResources-$name", GenerateResources) {
        outputDirectory = file("$buildDir/generated/$name/cpp")
        baseDirectory = file("$projectDir/src/$name/native/resources")
        source(files("$projectDir/src/$name/native/resources"))
        prefix = _prefix
        namespace = _namespace
    }
    return task
}
