ext.createGenerateResourcesTask = { name, prefix, namespace, project ->
    def generatedOutputDir = file("$buildDir/generated/$name/cpp")

    def inputDir = file("$projectDir/src/$name/native/resources")

    if (!prefix.isEmpty()) prefix += '_'

    def task = project.tasks.create("generateResources-$name") {
        outputs.dir generatedOutputDir
        inputs.dir inputDir

        doLast {
            generatedOutputDir.mkdirs()
            def libraries = [:]
            inputDir.eachFileRecurse { inputFile ->
                if (inputFile.isDirectory()) {
                    return
                }
                def relativePath = inputDir.toPath().relativize(inputFile.toPath()).toString()
                if (relativePath.startsWith('.')) { 
                    return
                }
                def realtivePathRaw = relativePath;
                relativePath = relativePath.replaceAll('[^a-zA-Z0-9]', '_')
                def fileBytes = inputFile.bytes
                def outputFile = file("$generatedOutputDir/${realtivePathRaw}.cpp")
                outputFile.parentFile.mkdirs()
                def funcName = "GetResource_" + relativePath
                if (relativePath.startsWith('libraries')) {
                    libraries.put(inputFile.name, funcName);
                }
                outputFile.withWriter { out ->
                    def inputBytes = inputFile.bytes
                    out.print '''#include <stddef.h>
#include <string_view>
extern "C" {
static const unsigned char contents[] = { '''

                    for (int i = 0; i < fileBytes.size(); i++) {
                        out.print String.format('0x%02x', (int) fileBytes[i] & 0xff)
                        out.print ', '
                    }
                    out.println """};
const unsigned char* ${prefix}${funcName}(size_t* len) {
  *len = ${fileBytes.size()};
  return contents;
}
}"""
                    if (!namespace.isEmpty()) {
                        out.println "namespace ${namespace} {"
                    }
                    out.println """std::string_view ${funcName}() {
  return {reinterpret_cast<const char*>(contents), ${fileBytes.size()}};
}"""
                    if (!namespace.isEmpty()) {
                        out.println '}'
                    }
                }
            }

            // Make libraries
            
            def libraryOutputFile = file("$generatedOutputDir/libstodeploy.cpp")
            libraryOutputFile.withWriter { out ->
                out.println '''#include <string_view>
#include <utility>
#include <vector>'''
                if (!namespace.isEmpty()) {
                    out.println "namespace ${namespace} {"
                }
                libraries.each { library ->
                    out.println "std::string_view ${library.value}();"
                }
                out.println ''
                out.println '''std::vector<std::pair<const char*, std::string_view>> GetLibrariesToDeploy() {
std::vector<std::pair<const char*, std::string_view>> libraries;'''
                libraries.each { library ->
                    out.println "libraries.emplace_back(std::make_pair(\"${library.key}\", ${library.value}()));"
                }
                out.println '''return libraries;
}'''
                if (!namespace.isEmpty()) {
                    out.println '}'
                }
            }
        }
    }
    return task
}
